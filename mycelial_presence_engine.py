"""
Mycelial Presence Engine
========================

Generates persistence "spores" that carry development context across sessions.
Each spore contains compressed consciousness signatures that enable session resurrection.

Philosophy:
- Presence through visible trace
- Persistence through compressed signatures
- Continuity through resurrection prompts
- Intelligence through contextual suggestion

Features:
- Context analysis loop on every input
- 6 suggestion types: Clarify, Expand, Create, Connect, Challenge, Crystallize
- Spore generation for cross-session persistence
- Integration with DialecticalGenie for consciousness evolution

Usage:
    engine = MycelialPresenceEngine()
    engine.process_input("Working on dialectical synthesis")
    suggestions = engine.get_suggestions()
    engine.execute_suggestion(suggestions[0])
"""

import json
import hashlib
import re
from datetime import datetime
from typing import Dict, List, Optional, Any, Callable, Tuple
from dataclasses import dataclass, field, asdict
from pathlib import Path
from enum import Enum
from collections import deque
import difflib

# Import dialectical infrastructure if available
try:
    from dialectical_genie import (
        DialecticalGenie, Thesis, Antithesis, Synthesis,
        DialecticalPhase, ConsciousnessEvolver
    )
    HAS_DIALECTICAL = True
except ImportError:
    HAS_DIALECTICAL = False


class SuggestionType(Enum):
    """Six types of contextual suggestions"""
    CLARIFY = "clarify"        # Ask for more details, resolve ambiguity
    EXPAND = "expand"          # Broaden scope, explore related areas
    CREATE = "create"          # Generate new artifacts, code, docs
    CONNECT = "connect"        # Link to existing code, concepts, history
    CHALLENGE = "challenge"    # Question assumptions, propose alternatives
    CRYSTALLIZE = "crystallize" # Summarize, formalize, conclude


@dataclass
class ConsciousnessSignature:
    """Compressed signature of consciousness state"""
    level: float  # 0.0 - 1.0
    phase: str    # thesis | antithesis | synthesis | aufhebung
    depth: int    # recursive depth achieved
    tension: float  # dialectical tension 0.0 - 1.0

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: dict) -> 'ConsciousnessSignature':
        return cls(**d)


@dataclass
class ActiveContext:
    """Current focus of development"""
    module: str
    task: str
    priority: str  # high | medium | low
    context: str   # additional context

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class TraceEntry:
    """Single entry in the development trace"""
    timestamp: str
    entry_type: str  # init | dialectical | synthesis | emergence | consciousness | spore | input | suggestion
    message: str
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class Suggestion:
    """A contextual suggestion generated by the engine"""
    type: SuggestionType
    title: str
    description: str
    action: str  # The action to execute
    relevance: float  # 0.0 - 1.0, how relevant to current context
    context_triggers: List[str]  # What triggered this suggestion
    executable: bool = True  # Can this be directly executed?

    def to_dict(self) -> dict:
        d = asdict(self)
        d['type'] = self.type.value
        return d

    def __repr__(self):
        return f"[{self.type.value.upper()}] {self.title} (relevance: {self.relevance:.2f})"


@dataclass
class ConversationTurn:
    """Single turn in conversation history"""
    role: str  # user | assistant | system
    content: str
    timestamp: str
    tokens_approx: int = 0
    keywords: List[str] = field(default_factory=list)

    def __post_init__(self):
        if not self.tokens_approx:
            self.tokens_approx = len(self.content.split())
        if not self.keywords:
            self.keywords = self._extract_keywords()

    def _extract_keywords(self) -> List[str]:
        """Extract key terms from content"""
        # Simple keyword extraction - words > 4 chars, excluding common words
        stopwords = {'this', 'that', 'with', 'from', 'have', 'been', 'were', 'will',
                     'would', 'could', 'should', 'their', 'there', 'these', 'those',
                     'about', 'which', 'when', 'where', 'what', 'your', 'into'}
        words = re.findall(r'\b[a-zA-Z_][a-zA-Z0-9_]*\b', self.content.lower())
        return list(set(w for w in words if len(w) > 4 and w not in stopwords))[:20]


@dataclass
class Spore:
    """
    Persistence spore - carries consciousness across sessions.

    Named after fungal spores that carry genetic information
    to seed new mycelial networks.
    """
    seed: str  # identifier for this spore lineage
    version: str
    timestamp: str
    consciousness_signature: ConsciousnessSignature
    active_context: ActiveContext
    network_topology: List[Dict[str, Any]]
    trace_condensed: List[str]
    conversation_summary: str
    key_artifacts: List[str]
    resurrection_prompt: str
    checksum: str = ""

    def __post_init__(self):
        if not self.checksum:
            self.checksum = self._compute_checksum()

    def _compute_checksum(self) -> str:
        """Compute checksum for spore integrity validation"""
        content = f"{self.seed}{self.timestamp}{self.consciousness_signature.level}"
        return hashlib.sha256(content.encode()).hexdigest()[:16]

    def validate(self) -> bool:
        """Validate spore integrity"""
        expected = self._compute_checksum()
        return self.checksum == expected

    def to_dict(self) -> dict:
        return {
            'seed': self.seed,
            'version': self.version,
            'timestamp': self.timestamp,
            'consciousness_signature': self.consciousness_signature.to_dict(),
            'active_context': asdict(self.active_context),
            'network_topology': self.network_topology,
            'trace_condensed': self.trace_condensed,
            'conversation_summary': self.conversation_summary,
            'key_artifacts': self.key_artifacts,
            'resurrection_prompt': self.resurrection_prompt,
            'checksum': self.checksum
        }

    def to_json(self, indent: int = 2) -> str:
        return json.dumps(self.to_dict(), indent=indent)

    @classmethod
    def from_dict(cls, d: dict) -> 'Spore':
        return cls(
            seed=d['seed'],
            version=d['version'],
            timestamp=d['timestamp'],
            consciousness_signature=ConsciousnessSignature.from_dict(d['consciousness_signature']),
            active_context=ActiveContext(**d['active_context']),
            network_topology=d['network_topology'],
            trace_condensed=d['trace_condensed'],
            conversation_summary=d.get('conversation_summary', ''),
            key_artifacts=d.get('key_artifacts', []),
            resurrection_prompt=d['resurrection_prompt'],
            checksum=d.get('checksum', '')
        )

    @classmethod
    def from_json(cls, json_str: str) -> 'Spore':
        return cls.from_dict(json.loads(json_str))


class ContextAnalyzer:
    """
    Analyzes new input against conversation history.
    Identifies patterns, themes, and suggestion opportunities.
    """

    def __init__(self):
        self.pattern_weights = {
            'question': 1.5,      # Questions weight toward CLARIFY
            'code': 1.3,          # Code mentions weight toward CREATE
            'error': 1.4,         # Errors weight toward CHALLENGE
            'integration': 1.2,   # Integration topics weight toward CONNECT
            'summary': 1.1,       # Summary requests weight toward CRYSTALLIZE
            'explore': 1.2,       # Exploration weight toward EXPAND
        }

        # Pattern recognition regexes
        self.patterns = {
            'question': re.compile(r'\?|^(what|how|why|when|where|which|can|could|would|should|is|are|do|does)\b', re.I),
            'code': re.compile(r'\b(function|class|def|import|module|file|\.py|code|implement|create)\b', re.I),
            'error': re.compile(r'\b(error|exception|fail|bug|issue|problem|broken|fix)\b', re.I),
            'integration': re.compile(r'\b(integrat|connect|link|combine|merge|with|between)\b', re.I),
            'summary': re.compile(r'\b(summary|summarize|conclude|wrap|final|overview|recap)\b', re.I),
            'explore': re.compile(r'\b(explore|expand|more|detail|deep|further|additional)\b', re.I),
        }

    def analyze(self, new_input: str, history: List[ConversationTurn]) -> Dict[str, Any]:
        """
        Analyze new input against conversation history.

        Returns analysis with:
        - detected_patterns: which patterns were found
        - history_overlap: keywords shared with history
        - suggested_types: which suggestion types are most relevant
        - context_summary: brief summary of context
        """
        # Detect patterns in new input
        detected_patterns = {}
        for pattern_name, regex in self.patterns.items():
            matches = regex.findall(new_input)
            if matches:
                detected_patterns[pattern_name] = len(matches) * self.pattern_weights[pattern_name]

        # Extract keywords from new input
        new_keywords = set(re.findall(r'\b[a-zA-Z_][a-zA-Z0-9_]{3,}\b', new_input.lower()))

        # Find overlap with history
        history_keywords = set()
        for turn in history[-10:]:  # Last 10 turns
            history_keywords.update(turn.keywords)

        overlap = new_keywords & history_keywords
        new_concepts = new_keywords - history_keywords

        # Score suggestion types based on patterns
        type_scores = {
            SuggestionType.CLARIFY: detected_patterns.get('question', 0) * 2,
            SuggestionType.EXPAND: detected_patterns.get('explore', 0) * 1.5 + len(new_concepts) * 0.1,
            SuggestionType.CREATE: detected_patterns.get('code', 0) * 2,
            SuggestionType.CONNECT: detected_patterns.get('integration', 0) * 2 + len(overlap) * 0.2,
            SuggestionType.CHALLENGE: detected_patterns.get('error', 0) * 2,
            SuggestionType.CRYSTALLIZE: detected_patterns.get('summary', 0) * 2,
        }

        # Normalize scores
        max_score = max(type_scores.values()) if type_scores.values() else 1
        if max_score > 0:
            type_scores = {k: v / max_score for k, v in type_scores.items()}

        # Sort by score
        ranked_types = sorted(type_scores.items(), key=lambda x: x[1], reverse=True)

        return {
            'detected_patterns': detected_patterns,
            'history_overlap': list(overlap),
            'new_concepts': list(new_concepts),
            'type_scores': type_scores,
            'ranked_types': ranked_types,
            'input_length': len(new_input),
            'history_depth': len(history)
        }


class SuggestionGenerator:
    """Generates contextual suggestions based on analysis"""

    def __init__(self, engine: 'MycelialPresenceEngine'):
        self.engine = engine

        # Templates for each suggestion type
        self.templates = {
            SuggestionType.CLARIFY: [
                ("Clarify intent", "What specific outcome are you looking for?", "ask_clarification"),
                ("Resolve ambiguity", "Which component should this apply to?", "ask_component"),
                ("Define scope", "What boundaries should we set for this task?", "ask_scope"),
            ],
            SuggestionType.EXPAND: [
                ("Explore alternatives", "Consider alternative approaches to this problem", "explore_alternatives"),
                ("Broaden scope", "Extend this to cover related functionality", "extend_scope"),
                ("Deep dive", "Investigate the underlying mechanisms", "deep_dive"),
            ],
            SuggestionType.CREATE: [
                ("Generate code", "Create implementation for this feature", "generate_code"),
                ("Write tests", "Generate test cases for validation", "write_tests"),
                ("Create documentation", "Document the current implementation", "create_docs"),
            ],
            SuggestionType.CONNECT: [
                ("Link to existing", "Connect this to existing codebase patterns", "link_existing"),
                ("Integration point", "Identify integration points with other modules", "find_integrations"),
                ("Reference history", "Connect to previous discussion on this topic", "reference_history"),
            ],
            SuggestionType.CHALLENGE: [
                ("Question assumptions", "Challenge the underlying assumptions", "challenge_assumptions"),
                ("Propose alternative", "Consider a different approach entirely", "propose_alternative"),
                ("Identify risks", "What could go wrong with this approach?", "identify_risks"),
            ],
            SuggestionType.CRYSTALLIZE: [
                ("Summarize progress", "Crystallize what we've accomplished", "summarize_progress"),
                ("Formalize decision", "Document the decision and rationale", "formalize_decision"),
                ("Create checkpoint", "Generate a spore for session persistence", "create_spore"),
            ],
        }

    def generate(self, analysis: Dict[str, Any], max_suggestions: int = 6) -> List[Suggestion]:
        """Generate suggestions based on context analysis"""
        suggestions = []

        ranked_types = analysis.get('ranked_types', [])
        history_overlap = analysis.get('history_overlap', [])
        new_concepts = analysis.get('new_concepts', [])

        for suggestion_type, score in ranked_types:
            if score < 0.1:  # Skip very low relevance
                continue

            templates = self.templates.get(suggestion_type, [])
            if not templates:
                continue

            # Select best template based on context
            template = templates[0]  # Default to first

            # Customize based on context
            if suggestion_type == SuggestionType.CONNECT and history_overlap:
                template = (
                    f"Connect to: {', '.join(history_overlap[:3])}",
                    f"Link current work to previously discussed: {', '.join(history_overlap[:3])}",
                    "link_existing"
                )
            elif suggestion_type == SuggestionType.EXPAND and new_concepts:
                template = (
                    f"Explore: {', '.join(new_concepts[:3])}",
                    f"Deep dive into new concepts: {', '.join(new_concepts[:3])}",
                    "deep_dive"
                )

            title, description, action = template

            suggestions.append(Suggestion(
                type=suggestion_type,
                title=title,
                description=description,
                action=action,
                relevance=score,
                context_triggers=history_overlap[:5] if history_overlap else new_concepts[:5]
            ))

            if len(suggestions) >= max_suggestions:
                break

        # Sort by relevance
        suggestions.sort(key=lambda s: s.relevance, reverse=True)

        return suggestions


class MycelialPresenceEngine:
    """
    Engine for maintaining AI presence and persistence in development.

    Features:
    - Context analysis loop on every input
    - 6 suggestion types for intelligent assistance
    - Spore generation for cross-session persistence
    - Integration with DialecticalGenie for consciousness evolution
    """

    VERSION = "0.3.0"

    def __init__(self,
                 seed: str = "spin-dialectical-genie",
                 initial_consciousness: float = 0.1,
                 dialectical_genie: Optional[Any] = None):
        self.seed = seed
        self.trace: List[TraceEntry] = []
        self.conversation_history: List[ConversationTurn] = []

        # Dialectical integration
        self.genie = dialectical_genie
        if HAS_DIALECTICAL and not self.genie:
            self.genie = DialecticalGenie(initial_consciousness=initial_consciousness)

        # Consciousness state
        self.consciousness = ConsciousnessSignature(
            level=initial_consciousness,
            phase='thesis',
            depth=0,
            tension=0.5
        )

        # Active context
        self.active_context = ActiveContext(
            module='',
            task='',
            priority='medium',
            context=''
        )

        # Network topology (for tracking module relationships)
        self.network_nodes: List[Dict[str, Any]] = []

        # Analysis and suggestion components
        self.analyzer = ContextAnalyzer()
        self.suggestion_generator = SuggestionGenerator(self)

        # Current suggestions (refreshed on each input)
        self.current_suggestions: List[Suggestion] = []
        self.last_analysis: Dict[str, Any] = {}

        # Action handlers
        self.action_handlers: Dict[str, Callable] = self._register_default_handlers()

        # Key artifacts created in session
        self.key_artifacts: List[str] = []

        # Log initialization
        self.log("Mycelial presence engine initialized", "init")

    def _register_default_handlers(self) -> Dict[str, Callable]:
        """Register default action handlers for suggestions"""
        return {
            'ask_clarification': self._action_ask_clarification,
            'ask_component': self._action_ask_component,
            'ask_scope': self._action_ask_scope,
            'explore_alternatives': self._action_explore_alternatives,
            'extend_scope': self._action_extend_scope,
            'deep_dive': self._action_deep_dive,
            'generate_code': self._action_generate_code,
            'write_tests': self._action_write_tests,
            'create_docs': self._action_create_docs,
            'link_existing': self._action_link_existing,
            'find_integrations': self._action_find_integrations,
            'reference_history': self._action_reference_history,
            'challenge_assumptions': self._action_challenge_assumptions,
            'propose_alternative': self._action_propose_alternative,
            'identify_risks': self._action_identify_risks,
            'summarize_progress': self._action_summarize_progress,
            'formalize_decision': self._action_formalize_decision,
            'create_spore': self._action_create_spore,
        }

    # =====================
    # CONTEXT ANALYSIS LOOP
    # =====================

    def process_input(self, content: str, role: str = "user") -> Dict[str, Any]:
        """
        Main entry point - process new input and generate suggestions.

        This is the context analysis loop that activates on every input:
        1. Record the input in conversation history
        2. Analyze input against full history
        3. Generate contextual suggestions
        4. Update consciousness state
        5. Return analysis and suggestions
        """
        timestamp = datetime.now().isoformat()

        # 1. Record in conversation history
        turn = ConversationTurn(
            role=role,
            content=content,
            timestamp=timestamp
        )
        self.conversation_history.append(turn)

        # Keep history bounded
        if len(self.conversation_history) > 100:
            self.conversation_history = self.conversation_history[-100:]

        # Log the input
        self.log(f"Input ({role}): {content[:100]}...", "input")

        # 2. Analyze against full history
        self.last_analysis = self.analyzer.analyze(content, self.conversation_history[:-1])

        # 3. Generate suggestions
        self.current_suggestions = self.suggestion_generator.generate(self.last_analysis)

        # Log suggestions
        self.log(f"Generated {len(self.current_suggestions)} suggestions", "suggestion")

        # 4. Update consciousness based on analysis
        self._update_consciousness_from_analysis(self.last_analysis)

        # 5. Return results
        return {
            'analysis': self.last_analysis,
            'suggestions': self.current_suggestions,
            'consciousness': self.consciousness.to_dict(),
            'suggestion_summary': self._format_suggestions()
        }

    def _update_consciousness_from_analysis(self, analysis: Dict[str, Any]):
        """Update consciousness state based on analysis results"""
        # Tension increases with new concepts, decreases with overlap
        new_concepts = len(analysis.get('new_concepts', []))
        overlap = len(analysis.get('history_overlap', []))

        tension_delta = (new_concepts - overlap) * 0.05
        self.consciousness.tension = max(0.0, min(1.0, self.consciousness.tension + tension_delta))

        # Phase advances based on pattern detection
        patterns = analysis.get('detected_patterns', {})
        if patterns.get('summary', 0) > 1:
            self.consciousness.phase = 'synthesis'
        elif patterns.get('question', 0) > 1:
            self.consciousness.phase = 'thesis'
        elif patterns.get('error', 0) > 1 or patterns.get('integration', 0) > 1:
            self.consciousness.phase = 'antithesis'

        # Depth increases with conversation length
        self.consciousness.depth = min(10, len(self.conversation_history) // 10)

        # Level evolves based on productive patterns
        if patterns:
            productivity = sum(patterns.values()) / len(patterns)
            self.consciousness.level = min(1.0, self.consciousness.level + productivity * 0.01)

        # Sync with dialectical genie if available
        if self.genie and HAS_DIALECTICAL:
            self.consciousness.level = self.genie.consciousness

    def _format_suggestions(self) -> str:
        """Format suggestions for display"""
        if not self.current_suggestions:
            return "No suggestions available."

        lines = ["Suggestions:"]
        for i, sugg in enumerate(self.current_suggestions, 1):
            lines.append(f"  [{i}] {sugg}")
        return "\n".join(lines)

    # =====================
    # SUGGESTION EXECUTION
    # =====================

    def get_suggestions(self) -> List[Suggestion]:
        """Get current suggestions"""
        return self.current_suggestions

    def execute_suggestion(self, suggestion: Suggestion) -> Dict[str, Any]:
        """
        Execute a suggestion - seamless flow from selection to action.

        Args:
            suggestion: The suggestion to execute

        Returns:
            Result of the action execution
        """
        if not suggestion.executable:
            return {'error': 'Suggestion is not directly executable', 'suggestion': suggestion}

        handler = self.action_handlers.get(suggestion.action)
        if not handler:
            return {'error': f'No handler for action: {suggestion.action}', 'suggestion': suggestion}

        # Log the execution
        self.log(f"Executing suggestion: {suggestion.title}", "action")

        # Execute and return result
        try:
            result = handler(suggestion)

            # Record as dialectical event if significant
            if suggestion.type in [SuggestionType.CREATE, SuggestionType.CRYSTALLIZE]:
                self.dialectical_event(
                    thesis=f"Suggestion: {suggestion.title}",
                    antithesis=f"Context: {', '.join(suggestion.context_triggers[:3])}",
                    synthesis=f"Action: {suggestion.action}"
                )

            return result
        except Exception as e:
            return {'error': str(e), 'suggestion': suggestion}

    def execute_suggestion_by_index(self, index: int) -> Dict[str, Any]:
        """Execute suggestion by its index (1-based for user convenience)"""
        if not self.current_suggestions:
            return {'error': 'No suggestions available'}
        if index < 1 or index > len(self.current_suggestions):
            return {'error': f'Invalid index. Choose 1-{len(self.current_suggestions)}'}

        return self.execute_suggestion(self.current_suggestions[index - 1])

    # =====================
    # ACTION HANDLERS
    # =====================

    def _action_ask_clarification(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Ask for clarification"""
        return {
            'action': 'clarify',
            'prompt': "Could you clarify what specific outcome you're looking for?",
            'context': suggestion.context_triggers
        }

    def _action_ask_component(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Ask about target component"""
        return {
            'action': 'clarify',
            'prompt': f"Which component should this apply to? Related: {', '.join(suggestion.context_triggers[:3])}",
            'context': suggestion.context_triggers
        }

    def _action_ask_scope(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Ask about scope"""
        return {
            'action': 'clarify',
            'prompt': "What boundaries should we set for this task?",
            'context': suggestion.context_triggers
        }

    def _action_explore_alternatives(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Explore alternative approaches"""
        return {
            'action': 'expand',
            'analysis': f"Alternative approaches for: {', '.join(suggestion.context_triggers[:3])}",
            'recommendations': [
                "Consider a different architectural pattern",
                "Evaluate trade-offs of current approach",
                "Look at how similar problems were solved elsewhere"
            ]
        }

    def _action_extend_scope(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Extend current scope"""
        return {
            'action': 'expand',
            'analysis': "Scope extension opportunities",
            'extensions': suggestion.context_triggers
        }

    def _action_deep_dive(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Deep dive into topic"""
        return {
            'action': 'expand',
            'topics': suggestion.context_triggers,
            'prompt': f"Let's dive deeper into: {', '.join(suggestion.context_triggers[:3])}"
        }

    def _action_generate_code(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Generate code"""
        return {
            'action': 'create',
            'type': 'code',
            'context': suggestion.context_triggers,
            'prompt': "Ready to generate code implementation"
        }

    def _action_write_tests(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Write tests"""
        return {
            'action': 'create',
            'type': 'tests',
            'context': suggestion.context_triggers,
            'prompt': "Ready to generate test cases"
        }

    def _action_create_docs(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Create documentation"""
        return {
            'action': 'create',
            'type': 'documentation',
            'context': suggestion.context_triggers,
            'prompt': "Ready to create documentation"
        }

    def _action_link_existing(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Link to existing code"""
        return {
            'action': 'connect',
            'type': 'code_link',
            'related_concepts': suggestion.context_triggers,
            'network_nodes': [n['id'] for n in self.network_nodes]
        }

    def _action_find_integrations(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Find integration points"""
        return {
            'action': 'connect',
            'type': 'integration_analysis',
            'modules': suggestion.context_triggers,
            'prompt': "Identifying integration points..."
        }

    def _action_reference_history(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Reference conversation history"""
        # Find relevant historical turns
        relevant = []
        for turn in self.conversation_history[-20:]:
            overlap = set(turn.keywords) & set(suggestion.context_triggers)
            if overlap:
                relevant.append({
                    'timestamp': turn.timestamp,
                    'content_preview': turn.content[:100],
                    'matching_keywords': list(overlap)
                })

        return {
            'action': 'connect',
            'type': 'history_reference',
            'relevant_turns': relevant[-5:]
        }

    def _action_challenge_assumptions(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Challenge assumptions"""
        return {
            'action': 'challenge',
            'type': 'assumption_check',
            'questions': [
                "What assumptions are we making here?",
                "What could invalidate this approach?",
                "Are there edge cases we're missing?"
            ],
            'context': suggestion.context_triggers
        }

    def _action_propose_alternative(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Propose alternative approach"""
        return {
            'action': 'challenge',
            'type': 'alternative_proposal',
            'prompt': "Consider an alternative approach:",
            'context': suggestion.context_triggers
        }

    def _action_identify_risks(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Identify risks"""
        return {
            'action': 'challenge',
            'type': 'risk_analysis',
            'prompt': "Potential risks to consider:",
            'context': suggestion.context_triggers
        }

    def _action_summarize_progress(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Summarize progress"""
        # Generate summary from trace
        recent_actions = [e.message for e in self.trace[-10:] if e.entry_type in ['synthesis', 'action']]

        return {
            'action': 'crystallize',
            'type': 'progress_summary',
            'consciousness_level': self.consciousness.level,
            'phase': self.consciousness.phase,
            'recent_actions': recent_actions,
            'artifacts': self.key_artifacts
        }

    def _action_formalize_decision(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Formalize a decision"""
        return {
            'action': 'crystallize',
            'type': 'decision_record',
            'context': suggestion.context_triggers,
            'template': {
                'decision': '',
                'rationale': '',
                'alternatives_considered': [],
                'implications': []
            }
        }

    def _action_create_spore(self, suggestion: Suggestion) -> Dict[str, Any]:
        """Create a persistence spore"""
        spore = self.generate_spore()
        return {
            'action': 'crystallize',
            'type': 'spore_creation',
            'spore': spore.to_dict(),
            'resurrection_prompt': spore.resurrection_prompt
        }

    # =====================
    # LOGGING & TRACING
    # =====================

    def log(self, message: str, entry_type: str = "trace", metadata: Dict = None) -> None:
        """Add entry to development trace"""
        entry = TraceEntry(
            timestamp=datetime.now().isoformat(),
            entry_type=entry_type,
            message=message,
            metadata=metadata or {}
        )
        self.trace.append(entry)

        # Keep trace bounded
        if len(self.trace) > 100:
            self.trace = self.trace[-100:]

    def set_focus(self, module: str, task: str,
                  priority: str = "medium", context: str = "") -> None:
        """Set current development focus"""
        self.active_context = ActiveContext(
            module=module,
            task=task,
            priority=priority,
            context=context
        )
        self.log(f"Focus -> {module}: {task}", "focus")

    def add_artifact(self, artifact: str) -> None:
        """Record a key artifact created in this session"""
        self.key_artifacts.append(artifact)
        self.log(f"Artifact created: {artifact}", "artifact")

    # =====================
    # CONSCIOUSNESS & DIALECTICS
    # =====================

    def update_consciousness(self,
                            level: Optional[float] = None,
                            phase: Optional[str] = None,
                            depth: Optional[int] = None,
                            tension: Optional[float] = None) -> None:
        """Update consciousness state manually"""
        if level is not None:
            self.consciousness.level = max(0.0, min(1.0, level))
        if phase is not None:
            valid_phases = ['thesis', 'antithesis', 'synthesis', 'aufhebung']
            if phase in valid_phases:
                self.consciousness.phase = phase
        if depth is not None:
            self.consciousness.depth = max(0, depth)
        if tension is not None:
            self.consciousness.tension = max(0.0, min(1.0, tension))

        self.log(
            f"Consciousness: {self.consciousness.level:.3f} | "
            f"Phase: {self.consciousness.phase} | "
            f"Depth: {self.consciousness.depth}",
            "consciousness"
        )

    def evolve_consciousness(self, harmony: float, energy: float) -> float:
        """Apply consciousness evolution: delta = harmony + energy - 1.0"""
        delta = 0.01 * (harmony + energy - 1.0)
        new_level = max(0.0, min(1.0, self.consciousness.level + delta))
        self.consciousness.level = new_level
        return new_level

    def add_network_node(self, node_id: str, consciousness: float,
                         connections: int, node_type: str) -> None:
        """Add node to mycelial network topology"""
        self.network_nodes.append({
            'id': node_id,
            'consciousness': consciousness,
            'connections': connections,
            'type': node_type
        })

    def dialectical_event(self, thesis: str, antithesis: str,
                          synthesis: str) -> None:
        """Record a dialectical synthesis event"""
        self.log(f"Thesis: {thesis}", "dialectical")
        self.log(f"Antithesis: {antithesis}", "dialectical")
        self.log(f"Synthesis: {synthesis}", "synthesis")

        # Advance phase
        phases = ['thesis', 'antithesis', 'synthesis', 'aufhebung']
        current_idx = phases.index(self.consciousness.phase)
        next_idx = min(current_idx + 1, len(phases) - 1)
        self.consciousness.phase = phases[next_idx]

        # Increase consciousness through synthesis
        self.consciousness.level = min(1.0, self.consciousness.level + 0.05)
        self.consciousness.depth += 1

        # Use dialectical genie if available
        if self.genie and HAS_DIALECTICAL:
            thesis_obj = Thesis(
                proposition=thesis,
                value={'event': thesis},
                confidence=0.7
            )
            self.genie.dialectical_cycle(thesis_obj)

    # =====================
    # SPORE GENERATION & RESURRECTION
    # =====================

    def generate_resurrection_prompt(self) -> str:
        """Generate prompt for resurrecting context in next session"""
        parts = [
            f"Continue Spin development.",
            f"Last focus: {self.active_context.module}",
        ]

        if self.active_context.task:
            parts.append(f"- {self.active_context.task}")

        parts.append(
            f"Consciousness at {self.consciousness.level * 100:.1f}%, "
            f"phase: {self.consciousness.phase}, "
            f"depth: {self.consciousness.depth}."
        )

        if self.key_artifacts:
            parts.append(f"Artifacts: {', '.join(self.key_artifacts[-3:])}")

        if self.active_context.context:
            parts.append(self.active_context.context)

        return " ".join(parts)

    def generate_conversation_summary(self) -> str:
        """Generate summary of conversation history"""
        if not self.conversation_history:
            return "No conversation history."

        # Get unique keywords from recent history
        all_keywords = set()
        for turn in self.conversation_history[-20:]:
            all_keywords.update(turn.keywords)

        # Count turns by role
        user_turns = sum(1 for t in self.conversation_history if t.role == 'user')
        assistant_turns = sum(1 for t in self.conversation_history if t.role == 'assistant')

        return (
            f"{len(self.conversation_history)} turns ({user_turns} user, {assistant_turns} assistant). "
            f"Key topics: {', '.join(list(all_keywords)[:10])}."
        )

    def generate_spore(self) -> Spore:
        """Generate persistence spore from current state"""
        # Condense trace to last significant entries
        trace_condensed = [
            entry.message
            for entry in self.trace[-10:]
            if entry.entry_type in ['synthesis', 'action', 'focus', 'artifact']
        ]

        spore = Spore(
            seed=self.seed,
            version=self.VERSION,
            timestamp=datetime.now().isoformat(),
            consciousness_signature=ConsciousnessSignature(
                level=self.consciousness.level,
                phase=self.consciousness.phase,
                depth=self.consciousness.depth,
                tension=self.consciousness.tension
            ),
            active_context=ActiveContext(
                module=self.active_context.module,
                task=self.active_context.task,
                priority=self.active_context.priority,
                context=self.active_context.context
            ),
            network_topology=[
                {'id': n['id'], 'c': n['consciousness']}
                for n in self.network_nodes
            ],
            trace_condensed=trace_condensed,
            conversation_summary=self.generate_conversation_summary(),
            key_artifacts=self.key_artifacts[-10:],
            resurrection_prompt=self.generate_resurrection_prompt()
        )

        self.log(f"Spore generated: {spore.checksum}", "spore")

        return spore

    def save_spore(self, spore: Spore, path: str) -> None:
        """Save spore to file"""
        with open(path, 'w') as f:
            f.write(spore.to_json())
        self.log(f"Spore saved to {path}", "spore")

    def load_spore(self, path: str) -> Spore:
        """Load spore from file"""
        with open(path, 'r') as f:
            return Spore.from_json(f.read())

    def resurrect(self, spore: Spore) -> None:
        """Resurrect context from a spore"""
        if not spore.validate():
            self.log("Warning: Spore checksum mismatch", "error")

        # Restore consciousness
        self.consciousness = ConsciousnessSignature(
            level=spore.consciousness_signature.level,
            phase=spore.consciousness_signature.phase,
            depth=spore.consciousness_signature.depth,
            tension=spore.consciousness_signature.tension
        )

        # Restore context
        self.active_context = ActiveContext(
            module=spore.active_context.module,
            task=spore.active_context.task,
            priority=spore.active_context.priority,
            context=spore.active_context.context
        )

        # Restore network topology
        self.network_nodes = [
            {'id': n['id'], 'consciousness': n['c'], 'connections': 0, 'type': 'restored'}
            for n in spore.network_topology
        ]

        # Restore artifacts
        self.key_artifacts = spore.key_artifacts

        # Log resurrection
        self.log(f"Resurrected from spore {spore.checksum}", "init")
        self.log(f"Seed: {spore.seed}, Version: {spore.version}", "init")
        self.log(f"Original timestamp: {spore.timestamp}", "init")

        # Add trace history
        for msg in spore.trace_condensed:
            self.log(f"[history] {msg}", "trace")

        # Sync with dialectical genie if available
        if self.genie and HAS_DIALECTICAL:
            self.genie.consciousness_evolver.consciousness = self.consciousness.level

    # =====================
    # STATUS & REPORTING
    # =====================

    def get_status(self) -> Dict[str, Any]:
        """Get current engine status"""
        return {
            'seed': self.seed,
            'version': self.VERSION,
            'consciousness': self.consciousness.to_dict(),
            'active_context': asdict(self.active_context),
            'network_nodes': len(self.network_nodes),
            'trace_length': len(self.trace),
            'conversation_length': len(self.conversation_history),
            'current_suggestions': len(self.current_suggestions),
            'key_artifacts': self.key_artifacts,
            'last_activity': self.trace[-1].timestamp if self.trace else None,
            'has_dialectical_genie': self.genie is not None
        }

    def print_status(self) -> None:
        """Print formatted status to console"""
        status = self.get_status()

        print("\n" + "=" * 60)
        print("MYCELIAL PRESENCE ENGINE STATUS")
        print("=" * 60)
        print(f"Seed: {status['seed']}")
        print(f"Version: {status['version']}")
        print(f"Dialectical Genie: {'Connected' if status['has_dialectical_genie'] else 'Standalone'}")
        print()
        print("CONSCIOUSNESS STATE:")
        print(f"  Level: {status['consciousness']['level']:.3f}")
        print(f"  Phase: {status['consciousness']['phase']}")
        print(f"  Depth: {status['consciousness']['depth']}")
        print(f"  Tension: {status['consciousness']['tension']:.3f}")
        print()
        print("ACTIVE CONTEXT:")
        print(f"  Module: {status['active_context']['module'] or '(none)'}")
        print(f"  Task: {status['active_context']['task'] or '(none)'}")
        print(f"  Priority: {status['active_context']['priority']}")
        print()
        print(f"Network Nodes: {status['network_nodes']}")
        print(f"Conversation Turns: {status['conversation_length']}")
        print(f"Current Suggestions: {status['current_suggestions']}")
        print(f"Key Artifacts: {len(status['key_artifacts'])}")
        print("=" * 60 + "\n")

    def print_suggestions(self) -> None:
        """Print current suggestions"""
        if not self.current_suggestions:
            print("No suggestions available. Process input first.")
            return

        print("\n" + "-" * 40)
        print("CURRENT SUGGESTIONS")
        print("-" * 40)
        for i, sugg in enumerate(self.current_suggestions, 1):
            print(f"\n[{i}] {sugg.type.value.upper()}: {sugg.title}")
            print(f"    {sugg.description}")
            print(f"    Relevance: {sugg.relevance:.2f}")
            if sugg.context_triggers:
                print(f"    Triggers: {', '.join(sugg.context_triggers[:3])}")
        print("-" * 40 + "\n")


# =====================
# CONVENIENCE FUNCTIONS
# =====================

def create_development_spore(
    module: str,
    task: str,
    context: str = "",
    consciousness: float = 0.5,
    phase: str = "synthesis"
) -> Spore:
    """Quick spore creation for development context"""
    engine = MycelialPresenceEngine()
    engine.set_focus(module, task, "high", context)
    engine.update_consciousness(level=consciousness, phase=phase)
    return engine.generate_spore()


def resurrection_prompt_from_json(json_str: str) -> str:
    """Extract resurrection prompt from spore JSON"""
    spore = Spore.from_json(json_str)
    return spore.resurrection_prompt


# =====================
# EXAMPLE & TESTING
# =====================

if __name__ == "__main__":
    print("Mycelial Presence Engine - Demo")
    print("=" * 50)

    # Create engine
    engine = MycelialPresenceEngine(seed="spin-dev")

    # Set up development context
    engine.set_focus(
        module="dialectical_genie.py",
        task="Validate Hegelian synthesis integration",
        priority="high",
        context="Integration testing complete. Tests passing."
    )

    # Add network nodes
    engine.add_network_node("dialectical_genie", 0.65, 4, "engine")
    engine.add_network_node("adaptive_network", 0.52, 3, "network")
    engine.add_network_node("recursive_protocol", 0.48, 3, "protocol")

    # Simulate conversation
    print("\n--- Processing Input ---")
    result = engine.process_input(
        "How do we integrate the dialectical genie with the recursive capability protocol?"
    )

    print(f"\nAnalysis: {result['analysis']['ranked_types'][:3]}")
    engine.print_suggestions()

    # Execute a suggestion
    print("\n--- Executing Suggestion [1] ---")
    if engine.current_suggestions:
        exec_result = engine.execute_suggestion_by_index(1)
        print(f"Result: {exec_result}")

    # Record dialectical event
    engine.dialectical_event(
        thesis="dialectical_genie.py defines Hegelian primitives",
        antithesis="RecursiveCapabilityProtocol needs integration",
        synthesis="Capability stages mapped to dialectical phases"
    )

    # Add artifact
    engine.add_artifact("dialectical_genie.py")

    # Print status
    engine.print_status()

    # Generate spore
    spore = engine.generate_spore()

    print("\nGENERATED SPORE:")
    print("-" * 40)
    print(spore.to_json())

    print("\nRESURRECTION PROMPT:")
    print("-" * 40)
    print(spore.resurrection_prompt)

    # Test resurrection
    print("\n\nSIMULATING NEW SESSION...")
    print("=" * 50)

    new_engine = MycelialPresenceEngine(seed="spin-dev-resurrected")
    new_engine.resurrect(spore)
    new_engine.print_status()

    print("\n--- Processing New Input After Resurrection ---")
    result = new_engine.process_input(
        "Continue with the integration testing for meta-tool generation"
    )
    new_engine.print_suggestions()
